
## 链表的定义 ##
	link list(链表)基础数据结构，是一种线性表，但是并不会按线性的链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
## 链表的组成 ##
	由一系列结点组成，节点包括两部分：数据域：存储数据元素，指针域：存储下一个节点的地址
## 链表的优点 ##
	插入、删除速度快、动态存储

### 插入、删除快的原理 ###
	插入时：链表不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度
	数组插入时：需要按照顺序存储，需要移动元素复杂度为O(n)
	删除时：链表：只需要删除
	数组：需要删除然后移动元素

## 数组的缺点 ##
	查找慢、占用空间大、容易造成内存碎片
	
### 查找慢的原理 ###
	查找慢的原因：原因是因为链表不是cache friendly(可缓存性)的。你在访问线性访问数组的时候，因为局部性原理，系统会把之后连续的内存都读过来，所以你之后访问数组元素可能都在 L1 cache(缓存) 里面，但链表不是这样的，谁都不知道它的next指针指到哪块内存，导致访问每个节点都对应一个memory(存储器)而不是cache的访问。

	链表与数组的各种操作复杂度如下所示：
	操作 ------------------- 链表 ---- 数组
	查找 -------------------- O(n) ---- O(1)
	在头部插入/删除 ------ O(1) ---- O(n)
	在尾部插入/删除 ------ O(n) ---- O(1)
	在中间插入/删除 ------ O(n) ---- O(n)
	额外的存储空间 ------- O(n) ----  0
	
	注意：虽然表面看起来复杂度都是 O(n)，但是链表和数组在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是历遍查找，删除和插入操作本身的复杂度是O(1)。数组查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，数组进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。
### 占用空间大的原理 ###
	原因：链表有结点。单向链表有指向下一个元素的结点；单项循环链表的最后一个元素有指向第一个元素的结点；双向循环链表有指向前一个元素的结点和指向后一个元素的结点。
	































