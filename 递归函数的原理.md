递归函数的原理
递归（recursion）就是子程序（或函数）直接调用自己或通过一系列调用语句间接调用自己，是一种描述问题和解决问题的基本方法。
 
    递归通常用来解决结构自相似的问题。所谓结构自相似，是指构成原问题的子问题与原问题在结构上相似，可以用类似的方法解决。具体地，整个问题的解决，可以分为两部分：第一部分是一些特殊情况，有直接的解法；第二部分与原问题相似，但比原问题的规模小。实际上，递归是把一个不能或不好解决的大问题转化为一个或几个小问题，再把这些小问题进一步分解成更小的问题，直至每个小问题都可以直接解决。因此，递归有两个基本要素：
 
    （1）边界条件：确定递归到何时终止，也称为递归出口。
 
    （2）递归模式：大问题是如何分解为小问题的，也称为递归体。递归函数只有具备了这两个要素，才能在有限次计算后得出结果
 
在递归函数中，调用函数和被调用函数是同一个函数，需要注意的是递归函数的调用层次，如果把调用递归函数的主函数称为第0层，进入函数后，首次递归调用自身称为第1层调用；从第i层递归调用自身称为第i+1层。反之，退出第i+1层调用应该返回第i层。
 
 
递归函数的内部执行过程
 
    一个递归函数的调用过程类似于多个函数的嵌套的调用，只不过调用函数和被调用函数是同一个函数。为了保证递归函数的正确执行，系统需设立一个工作栈。具体地说，递归调用的内部执行过程如下：
 
    （1）运动开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址；
 
    （2）每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址压栈；
 
    （3）每次递归调用结束后，将栈顶元素出栈，使相应的值参和局部变量恢复为调用前的值，然后转向返回地址指定的位置继续执行。 
 

 

以阶乘为例说明递归的工作原理：

long ff(int n) { long f; if(n<0)

printf("n<0,input error"); else if(n==0||n==1)

f=1; //为什么f=1,就不再继续递归调用？

else

f=ff(n-1)*n;//这一步到底是怎么工作的？ return(f); }

 
首先要清楚，递归就是某个函数直接或间接地调用了自身，这种调用方式叫做递归调用。说白了，还是函数调用。既然是函数调用，那么就有一个雷打不动的原则：所有被调用的函数都将创建一个副本，各自为调用者服务，而不受其他函数的影响。

你的ff函数，递归多少次，就有多少个副本，再利用内存的栈式管理，反向退出。这个最好找一下“栈”这方面的东西看看，挺容易的，就像子弹匣一样，先进后出。

你不理解，很有可能是因为误以为该这几行代码被反复使用了。从某种意义上说，这是不对的，因为就像刚才说的，一旦被调用，他将在内存中复制出一份代码，再被调用就再复制一份，换句话说，你可以吧同一个函数的多次调用理解称谓多个不同函数的一次调用，这样也会会简单些。

再说=1和=0是为什么退出。递归，很需要注意的就是死递归，也就是说，某一个函数进入了无限调用自身的情况，永无止境地消耗内存等资源，这在编程方面是一大忌。但凡是递归的函数，一定会在某一个地方存在能够返回上一层函数的代码，否则必定死递归。ff函数中，那个else就是返回的出口，你可以这样想，如果没有那个if来进行判断，你递归到什么时候算完？ff是不是会一直调用自己呢？别指望被调用的函数会自动结束，因为一旦某个函数A中调用了函数B（或者自己），那么A中的代码会停在调用的位置，而转向B中去执行，同理，如果B又调用函数C，那么B又停在调用的位置，去执行C，如果无限调用，那么程序是永远不会结束的。当然，也有这种情况，A调用B，然后继续自己的代码，不管B的死活，这种不在我们的讨论范围内，因为那牵扯到另一种编程方式：多线程。（我们现在说的是单线程）

给你拆极不看看吧：

求3!=?

一层执行到f=ff(3-1)*3;停止，执行二层ff(3-1),也就是ff(2)

二层执行到f=ff(2-1)*2;停止，执行三层ff(2-1)，也就是f(1)

三层执行到else if(n==0||n==1) f=1;然后return(f)到二层的ff(2-1)的位置，二层继续执行

二层执行f=1*2; 然后就return(f)到一层ff(3-1)的位置，一层继续执行

一层执行f=2*3; 然后就return(f)到了最初调用ff(3)的main函数里，所以就得到y=6

大体过程就是这样的

这里每次一层都相当于一个不同的函数，你可以给他们起名为ff1,ff2,ff3.....这样就不混了。只要注意一点，调用一次，不是在代码本身上执行，而是会复制出一份在执行，虽然不太恰当，但足以说明问题。


## 终止递归的方式 ##

- 使用全局变量

- 使用一个或多个参数

- 可能通过异常来控制递归的结束。其实这种情况很常见，每个应用程序的缺省栈空间大小是不会太大的，很容易因为堆栈溢出而让递归函数终止。此外，还可以会发生其它的异常，比如内存空间不足、除零等等。这些异常都可以让递归函数终止。

- 我们一般所说的全局变量都是针对一个应用程序而言的，所以我们还可以利用BIOS或OS的一些数据或一些标准库的全局值来控制递归过程的终止。比如利用日期时间、利用库中的随机数等等。





